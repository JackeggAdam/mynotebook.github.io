
# How Docker Containers Work

While using Docker containers sometimes looks, and feels, like you're using a virtual machine. If you are running it on a Linux host it is not being virtualized, in fact, Docker makes use of existing Linux Kernel functionalities to "contain" applications without almost any overhead.

To build our understanding how Docker works we can follow the following hint from the [Docker website](https://docs.docker.com/get-started/overview/#the-underlying-technology):
>  Docker uses a technology called namespaces to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container.

So, Docker seems to be build around this thing called "namespaces". What are these namespaces, and how does Docker use them?

TODO: Vs VMs: Kernel is shared in containers


## Namespaces

The namespace manual page[^man-namespaces] describes namespaces as:
> A namespace wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.

The essence of [Linux namespaces](https://en.wikipedia.org/wiki/Linux_namespaces) is that they allow us to run processes in isolated (contained) environments. To the process it looks like they are running in their own private environment. 

Namespaces are the basis for Docker containers, however they also have other applications. For example, Chrome uses them to provide secure sandboxes[^chromium-sandboxing].

There are a few different namespaces for different resources provided by the operating system. For example we can see the namespaces used by a process running in a container with `lsns`:
```
❯ docker run ubuntu lsns -o NS,TYPE,PID,PATH
        NS TYPE   PID PATH
4026531835 cgroup   1 /proc/1/ns/cgroup
4026531837 user     1 /proc/1/ns/user
4026533141 mnt      1 /proc/1/ns/mnt
4026533142 uts      1 /proc/1/ns/uts
4026533143 ipc      1 /proc/1/ns/ipc
4026533144 pid      1 /proc/1/ns/pid
4026533146 net      1 /proc/1/ns/net
```

We will explore some of these types of namespaces in more detail below:


### Process ID (PID) Namespace

On Linux, each process gets assigned a unique ID, the [process identifier (PID)](https://en.wikipedia.org/wiki/Process_identifier). This PID can be used to identify the process, and is for example used to get more info on the process via the [proc filesystem](https://en.wikipedia.org/wiki/Procfs).

Linux provides a namespaces to isolate this PID number space[^man-pid-namespaces-]:
> PID namespaces isolate the process ID number space, meaning that processes in different PID namespaces can have the same PID.

Docker containers use this PID namespace to provide isolation for processes[^man-pid-namespaces-]:
> PID namespaces allow containers to provide functionality such as suspending/resuming the set of processes in the container and migrating the container to a new host while the processes inside the container maintain the same PIDs.

Processes in a new PID namespace start at PID 1 [^man-pid-namespaces-]. The process with PID 1 typically has special responsibilities, so be careful which process will be the initial process when starting a container (TODO: Write up about tini, PID 1, and init processes). or example when we launch a long running process in a docker container (here `sleep 642`), we see that this process gets assigned PID 1 within that container:
```
❯ docker run --name tmp-sleeper -d ubuntu sleep 642
❯ docker exec tmp-sleeper ps -o pid,ppid,args
    PID    PPID COMMAND
      1       0 sleep 642
      7       0 ps -o pid,ppid,args
```

Notice that inside the container it looks like there are only two processes running: our `sleep` process, and the `ps` process getting the list of processes. Processes can only see other processes in their own PID namespace (any any descendant namespaces). The `ps` process running in the container PID namespace can thus only see the `sleep` command, which is running in the same namespace. So from the view of the container the processes are isolated from other processes.

PID namespaces are nested. When a new process is created it will have a PID for each namespace from its current namespace up to the initial ("root") PID namespace. When we check the processes running on the Linux host which is running the container we can find the same `sleep` process that is running on our container, although with a different PID (here 14478).
```
❯ ps axfo pid,ppid,args
    PID    PPID COMMAND
  14459       1 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 511b53c6ca104e69e92ee3da8ecf481dc571ee24b3c67776400ef0f253a4e020 -address /run/containerd/containerd.sock
  14478   14459  \_ sleep 642
```
Note that the `sleep` command has as parent the `containerd-shim` process. This `containerd-shim` is a service, running the Linux host, which is used by Docker to manage containers[^docker-containerd]. Depending on your version of Docker, this process could be named differently or have a different process tree.

From the processes PID on the Linux host we can also get more information about the namespace this process is part of. If we look at the proc filesystem[^man-proc] on the Linux host, then we can find the namespaces the process is part of and the PID of that process in those PID namespaces.
```
❯ cat /proc/14478/status | grep NSpid
NSpid:	10063	1
```
We see that our `sleep` process is part of PID namespace 10063, and has a PID of 1 in that namespace (as we confirmed before when looking at the container). 

This is the PID namespace in action. The container gets a new isolated PID namespace (with namespace ID 10063) with the first process (`sleep 642`) running assigned PID 1. However, since this new namespace is a descendant of the original root namespace on the Linux host, we can also see the `sleep` process on the Linux host running the container.


### Control group (cgroup) Namespace

[cgroups](https://en.wikipedia.org/wiki/Cgroups), or control groups, are a Linux kernel feature to monitor and control resource usage, such as CPU or memory usage.

The cgroup namespace type hides the identity of the control group of which process is a member. 

It is possible to view docker runtime metrics via:
```
❯ docker stats --no-stream
CONTAINER ID   NAME                   CPU %     MEM USAGE / LIMIT     MEM %     NET I/O       BLOCK I/O   PIDS
08b7204edaac   intelligent_bhaskara   0.00%     1.254MiB / 62.45GiB   0.00%     2.68kB / 0B   0B / 0B     1

...
```
The info


```
❯ cat /sys/fs/cgroup/cpuacct/docker/08b7204edaacf12ef6fb76f025fd3d5a8bcf358a35ddcedaeb951d9537993eb0/cpuacct.stat
user 1
system 2
```

```
❯ cat /sys/fs/cgroup/memory/docker/08b7204edaacf12ef6fb76f025fd3d5a8bcf358a35ddcedaeb951d9537993eb0/memory.usage_in_bytes
1314816

```

```
❯ cat /sys/fs/cgroup/blkio/docker/08b7204edaacf12ef6fb76f025fd3d5a8bcf358a35ddcedaeb951d9537993eb0/blkio.throttle.io_service_bytes
Total 0
```

### TODO: 
- https://www.datadoghq.com/blog/how-to-collect-docker-metrics/
- https://crate.io/a/analyzing-docker-container-performance-native-tools/
- https://docs.docker.com/engine/reference/commandline/stats/
- https://docs.docker.com/config/containers/runmetrics/

## References

* footnotes will be placed here. This line is necessary
{:footnotes}
- [^chromium-sandboxing]: [Linux Sandboxing in Chromium](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/linux/sandboxing.md)
- [^man-namespaces]: [`man namespaces`](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [^man-pid-namespaces-]: [`man pid_namespaces`](https://man7.org/linux/man-pages/man7/pid_namespaces.7.html)
- [^man-proc]: [`man proc`](https://man7.org/linux/man-pages/man5/proc.5.html)
- [^docker-containerd]: [What is containerd ? - Docker](https://www.docker.com/blog/what-is-containerd-runtime/)

## TODO:
- Talk about init
    - https://ahmet.im/blog/minimal-init-process-for-containers/
    - https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/
    - https://medium.com/@BeNitinAgarwal/an-init-system-inside-the-docker-container-3821ee233f4b
    - https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem0/
- WIll only work running from Linux host


To view / references:
- https://jvns.ca/blog/2016/10/10/what-even-is-a-container/
- https://itnext.io/linux-container-from-scratch-339c3ba0411d
- https://blog.codecentric.de/en/2019/06/docker-demystified/
- https://en.wikipedia.org/wiki/Linux_namespaces
- https://opensource.com/article/19/10/namespaces-and-containers-linux
- https://ibnusani.com/devopsmy-slides/docker-init.html
- https://fly.io/blog/docker-without-docker/?s=09
- https://www.youtube.com/watch?v=73nB9-HYbAI
- https://www.youtube.com/watch?v=0kJPa-1FuoI
- https://www.youtube.com/watch?v=-YnMr1lj4Z8
- https://www.youtube.com/watch?v=sK5i-N34im8
- https://www.youtube.com/watch?v=_TsSmSu57Zo
- https://www.youtube.com/watch?v=Utf-A4rODH8
- https://docs.google.com/document/d/1IyqdaCcpRDJiVqz2fGZEjn60P-nQR4GTaEA5MXA5FfM/edit
- https://www.youtube.com/watch?v=73nB9-HYbAI
- https://www.youtube.com/watch?v=J17rXQ5XkDE



References:
- https://www.redhat.com/sysadmin/cgroups-part-one